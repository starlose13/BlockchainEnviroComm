// SPDX-License-Identifier: MIT
pragma solidity 0.8.18;

import {Errors} from "../Helper/Errors.sol";
import {DataTypes} from "../Helper/DataTypes.sol";
import {INodeManager} from "../../interfaces/INodeManager.sol";
import {IConsensusMechanism} from "../../interfaces/IConsensusMechanism.sol";
import {Utils} from "./../Helper/Utils.sol";

contract ConsensusMechanism {
    INodeManager public nodeManager;

    uint8 private constant CONSENSUS_EPOCH = 2;
    uint8 private s_consensusThreshold = 1; // threshold for having a consensus
    uint private s_lastTimeStamp; // chainlink auto-execution time
    uint private immutable i_interval; // chainlink interval

    mapping(address => DataTypes.TargetLocation) public s_target;

    constructor(uint _i_interval, address _nodeManagerAddress) {
        s_lastTimeStamp = block.timestamp;
        i_interval = _i_interval;
        nodeManager = INodeManager(_nodeManagerAddress);
    }

    function reportTargetLocation(
        address _nodeAddress,
        DataTypes.TargetZone _announceTarget
    ) external {
        if (hasNodeParticipated(_nodeAddress) == true) {
            revert Errors.ConsensusMechanism__NODE_ALREADY_VOTED();
        }
        if (nodeManager.isNodeRegistered(_nodeAddress) == false) {
            revert Errors.ConsensusMechanism__NODE_NOT_REGISTERED();
        }

        s_target[msg.sender].zone = DataTypes.TargetZone(_announceTarget); // Location of target (lat & long) that reported
        s_target[msg.sender].reportedBy = msg.sender; // Address of the node that reported this location
        s_target[msg.sender].timestamp = block.timestamp; // Time when the location was reported
        s_target[msg.sender].isActive = true; //to mark if the proposal is still active
        emit DataTypes.TargetLocationReported(msg.sender, _announceTarget);
    }

    function initiateConsensusAttack() external {}

    function checkConsensusReached() external view returns (uint) {
        uint[] memory enumSelected = new uint[](
            uint(type(DataTypes.TargetZone).max) + 1
        );
        // Loop through participations (replace with your data source)
        for (uint i = 0; i < nodeManager.numberOfPresentNodes(); i++) {
            // locationCounts[participations[i]]++;
            address targetAddress = nodeManager.retrieveAddressByIndex(i);
            if (s_target[targetAddress].zone == DataTypes.TargetZone.lat) {
                enumSelected[1] += 1; // index of DataTypes.TargetZone of 1 (lat) it can be changed if the inputs of targetZone have been changed
            } else if (
                s_target[targetAddress].zone == DataTypes.TargetZone.long
            ) {
                enumSelected[2] += 1; //index of DataTypes.TargetZone of 2 (long) it can be changed if the inputs of targetZone have been changed
            }
        }
        return
            Utils.maxUnique(enumSelected) >= s_consensusThreshold
                ? Utils.maxUnique(enumSelected)
                : 0;
    }

    function hasNodeParticipated(
        address _nodeAddress
    ) public view returns (bool) {
        return (s_target[_nodeAddress].reportedBy != address(0));
    }

    function resetEpoch() external {
        for (uint i = 0; i < nodeManager.numberOfPresentNodes(); i++) {
            address targetAddress = nodeManager.retrieveAddressByIndex(i);
            s_target[targetAddress] = DataTypes.TargetLocation({
                zone: DataTypes.TargetZone(0), // Assuming 0 is a valid default value for TargetZone
                reportedBy: address(0),
                timestamp: 0,
                isActive: false
            });
        }
    }

    function resetAllTargetLocations() public {
        // Iterate over all addresses in the mapping
        for (uint i = 0; i < nodeManager.numberOfPresentNodes(); i++) {
            address targetAddress = nodeManager.retrieveAddressByIndex(i);

            // Nullify the TargetLocation struct for the current address
            delete s_target[targetAddress];
        }
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    ) external view returns (bool upkeepNeeded /* performData */) {
        upkeepNeeded = (block.timestamp - s_lastTimeStamp) > i_interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function fetchConsensusThreshold() external view returns (uint8) {
        return s_consensusThreshold;
    }

    function performUpkeep(bytes calldata /* performData */) external {
        if ((block.timestamp - s_lastTimeStamp) > i_interval) {
            s_lastTimeStamp = block.timestamp;
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }
}
